# Copyright (c) 2025 Konvt
# This file is licensed under the Mozilla Public License 2.0.
# See the LICENSE file in the project root for license terms.
import os
import re
import textwrap

def to_mod_str(modfpath: str) -> str:
  return modfpath.replace(os.sep, '.').removesuffix('.').removesuffix('init.lua').removesuffix('.lua')

def to_path_str(reqstr: str) -> str:
  return reqstr.replace('.', os.sep)

def find_module_file(searchpath: str, reqpath: str) -> tuple[str, bool]:
  fileprefix = f'{searchpath}{os.sep}{reqpath}'
  modfile = f'{fileprefix}.lua'
  if os.path.isfile(modfile):
    return f'{reqpath}.lua', False
  libfile = f'{fileprefix}{os.sep}init.lua'
  if os.path.isfile(libfile):
    return f'{reqpath}{os.sep}init.lua', True
  raise FileNotFoundError(f'file "{modfile}" or "{libfile}" not found at "{fileprefix}"')

def read_utf8(path: str) -> str:
  with open(path, 'r', encoding='utf-8') as f:
    return f.read()

class LuaPacker:
  RE_REQUIRE = re.compile(r'require\s*\(?\s*["\']([\w\.]+)["\']\s*\)?')
  RE_LUA_COMMENT = re.compile(r'--\[\[[\s\S]*?\]\]\n?|--[^\n]*\n?')

  @classmethod
  def remove_lua_comments(cls, content: str) -> str:
    return re.sub(cls.RE_LUA_COMMENT, '', content)

  @classmethod
  def find_require_modules(cls, content: str):
    return set(cls.RE_REQUIRE.findall(content))

  def __init__(self, entry: str, output: str):
    self.searchpath = os.path.abspath(os.path.dirname(entry))
    self.entry = os.path.relpath(entry, self.searchpath)
    self.output = output
    self.visited = set()
    self.modules = {}

  def pack(self):
    self.entry_content = self.remove_lua_comments(read_utf8(f'{self.searchpath}/{self.entry}'))
    for reqmod in self.find_require_modules(self.entry_content):
      filepath = to_path_str(reqmod)
      modfpath, is_lib = find_module_file(self.searchpath, filepath)
      self._scan_module(modfpath, None if not is_lib else reqmod)
    self._write_out()

  def _replace_requires_abs(self, content: str, libreqname: str) -> str:
    libpath = to_path_str(libreqname)
    def repl(m: re.Match) -> str:
      path = to_path_str(m.group(1))
      # FIXME: 现在无法处理库目录下的 init.lua 转发到另一个 static/init.lua 的情况
      # 所以暂时需要修改库文件的 init.lua 以适应变化
      if os.path.isfile(f'{libpath}{os.sep}{path}.lua'):
        return f'require(\'{libreqname}.{m.group(1)}\')'
      return f'require(\'{m.group(1)}\')'
    return re.sub(self.RE_REQUIRE, repl, content)

  def _scan_module(self, filepath: str, libreqname: str | None = None):
    '''
    Args:
      filepath (str): 模块文件路径，起点为 searchpath
      libreqname (str | None): 如果当前扫描的是库文件，libreqname 是相对于搜寻目录的 require 字符串
    '''
    if filepath in self.visited:
      return
    self.visited.add(filepath)

    content = self.remove_lua_comments(read_utf8(filepath))
    modname = to_mod_str(filepath)

    # 如果是 init.lua，替换里面 require 模块为绝对模块名
    if libreqname != None:
      content = self._replace_requires_abs(content, libreqname)

    # 递归依赖
    for reqmod in self.find_require_modules(content):
      filepath = to_path_str(reqmod)
      modfpath, is_lib = find_module_file(self.searchpath, filepath)
      self._scan_module(modfpath, reqmod if is_lib else libreqname if libreqname is not None else None)

    self.modules[modname.removesuffix('.')] = f'function(...)\n{content}\nend'

  def _write_out(self):
    with open(self.output, 'w', encoding='utf-8') as f:
      f.write(textwrap.dedent(f'''\
        -- This file is automatically generated by the packager.
        -- Please do not modify it manually.
        if package == nil then package = {{}} end
        if package.loaded == nil then package.loaded = {{}} end
        if package.preload == nil then package.preload = {{}} end
        if require == nil then
          require = function( name )
            if package.loaded[name] then
              return package.loaded[name]
            end
            local loader = package.preload[name]
            if not loader then
              error( 'module "' .. name .. '" not found' )
            end
            local mod = loader()
            package.loaded[name] = mod
            return mod
          end
        end\n'''))
      for mod, func in self.modules.items():
        f.write(f'package.loaded[\'{mod}\'] = nil\n'
                f'package.preload[\'{mod}\'] = {func}\n')
      f.write(self.entry_content)

import sys
import tempfile
import shutil
import zipfile

if __name__ == '__main__':
  if len(sys.argv) == 2 and sys.argv[1] == '.':
    base_dir = os.path.abspath(os.path.dirname(__file__))
    tmpdir = tempfile.mkdtemp(dir=base_dir)
    try:
      tmp_main = os.path.join(tmpdir, 'main.tmp.lua')
      LuaPacker('main.lua', tmp_main).pack()
      tmp_options = os.path.join(tmpdir, 'options.tmp.lua')
      LuaPacker('options.lua', tmp_options).pack()

      final_main = os.path.join(tmpdir, 'main.lua')
      final_options = os.path.join(tmpdir, 'options.lua')
      os.rename(tmp_main, final_main)
      os.rename(tmp_options, final_options)

      to_pack = [
        'images', 'sounds', 'vox',
        'info.txt', 'LICENSE', 'README.md',
        'preview.jpg',
        final_main, final_options
      ]

      zip_path = os.path.join(base_dir, 'GunshipAirstrike.zip')
      with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for item in to_pack:
          abs_item = os.path.join(base_dir, item) if not os.path.isabs(item) else item
          if os.path.isdir(abs_item):
            for root, _, files in os.walk(abs_item):
              for file in files:
                rel = os.path.relpath(os.path.join(root, file), base_dir)
                zipf.write(os.path.join(root, file), rel)
          elif os.path.isfile(abs_item):
            if abs_item.startswith(tmpdir):
              zipf.write(abs_item, os.path.basename(abs_item))
            else:
              rel = os.path.relpath(abs_item, base_dir)
              zipf.write(abs_item, rel)
    finally:
      shutil.rmtree(tmpdir)
    sys.exit(0)

  if len(sys.argv) != 3:
    print("Usage: python packer.py <input_file> <output_file>")
    sys.exit(1)

  input_file = sys.argv[1]
  output_file = sys.argv[2]

  if not os.path.isfile(input_file):
    print(f"Error: Input file '{input_file}' not found")
    sys.exit(1)

  LuaPacker(input_file, output_file).pack()

# Copyright (c) 2025 Konvt
# This file is licensed under the Mozilla Public License 2.0.
# See the LICENSE file in the project root for license terms.
import os
import re
import textwrap

def to_mod_str(modfpath: str) -> str:
  return modfpath.replace(os.sep, '.').removesuffix('.').removesuffix('init.lua').removesuffix('.lua')

def to_path_str(reqstr: str) -> str:
  return reqstr.replace('.', os.sep)

def find_module_file(searchpath: str, reqpath: str) -> tuple[str, bool]:
  fileprefix = f'{searchpath}{os.sep}{reqpath}'
  modfile = f'{fileprefix}.lua'
  if os.path.isfile(modfile):
    return f'{reqpath}.lua', False
  libfile = f'{fileprefix}{os.sep}init.lua'
  if os.path.isfile(libfile):
    return f'{reqpath}{os.sep}init.lua', True
  raise FileNotFoundError(f'file "{modfile}" or "{libfile}" not found at "{fileprefix}"')

def read_utf8(path: str) -> str:
  with open(path, 'r', encoding='utf-8') as f:
    return f.read()

class LuaPacker:
  RE_REQUIRE = re.compile(r'require\s*\(?\s*["\']([\w\.]+)["\']\s*\)?')
  RE_LUA_COMMENT = re.compile(r'--\[\[[\s\S]*?\]\]\n?|--[^\n]*\n?')

  @classmethod
  def remove_lua_comments(cls, content: str) -> str:
    return re.sub(cls.RE_LUA_COMMENT, '', content)

  @classmethod
  def find_require_modules(cls, content: str):
    return set(cls.RE_REQUIRE.findall(content))

  def __init__(self, entry: str, output: str):
    self.searchpath = os.path.abspath(os.path.dirname(entry))
    self.entry = os.path.relpath(entry, self.searchpath)
    self.output = output
    self.visited = set()
    self.modules = {}

  def pack(self):
    self.entry_content = self.remove_lua_comments(read_utf8(f'{self.searchpath}/{self.entry}'))
    for reqmod in self.find_require_modules(self.entry_content):
      filepath = to_path_str(reqmod)
      modfpath, is_lib = find_module_file(self.searchpath, filepath)
      self._scan_module(modfpath, None if not is_lib else reqmod)
    self._write_out()

  def _replace_requires_abs(self, content: str, libreqname: str) -> str:
    libpath = to_path_str(libreqname)
    def repl(m: re.Match) -> str:
      if os.path.isfile(f'{libpath}{os.sep}{to_path_str(m.group(1))}.lua'):
        return f'require(\'{libreqname}.{m.group(1)}\')'
      return f'require(\'{m.group(1)}\')'
    return re.sub(self.RE_REQUIRE, repl, content)

  def _scan_module(self, filepath: str, libreqname: str | None = None):
    '''
    Args:
      filepath (str): 模块文件路径，起点为 searchpath
      libreqname (str | None): 如果当前扫描的是库文件，libreqname 是相对于搜寻目录的 require 字符串
    '''
    if filepath in self.visited:
      return
    self.visited.add(filepath)

    content = self.remove_lua_comments(read_utf8(filepath))
    modname = to_mod_str(filepath)

    # 如果是 init.lua，替换里面 require 模块为绝对模块名
    if libreqname != None:
      content = self._replace_requires_abs(content, libreqname)

    # 递归依赖
    for reqmod in self.find_require_modules(content):
      filepath = to_path_str(reqmod)
      modfpath, is_lib = find_module_file(self.searchpath, filepath)
      self._scan_module(modfpath, reqmod if is_lib else libreqname if libreqname is not None else None)

    self.modules[modname.removesuffix('.')] = f'function(...)\n{content}\nend'

  def _write_out(self):
    with open(self.output, 'w', encoding='utf-8') as f:
      f.write(textwrap.dedent(f'''\
        -- This file is automatically generated by the packager.
        -- Please do not modify it manually.
        if package == nil then package = {{}} end
        if package.loaded == nil then package.loaded = {{}} end
        if package.preload == nil then package.preload = {{}} end
        if require == nil then
          require = function( name )
            if package.loaded[name] then
              return package.loaded[name]
            end
            local loader = package.preload[name]
            if not loader then
              error( 'module "' .. name .. '" not found' )
            end
            local mod = loader()
            package.loaded[name] = mod
            return mod
          end
        end\n'''))
      for mod, func in self.modules.items():
        f.write(f'package.loaded[\'{mod}\'] = nil\n'
                f'package.preload[\'{mod}\'] = {func}\n')
      f.write(self.entry_content)

import sys

if __name__ == '__main__':
  if len(sys.argv) != 3:
    print("Usage: python packer.py <input_file> <output_file>")
    sys.exit(1)

  input_file = sys.argv[1]
  output_file = sys.argv[2]

  if not os.path.isfile(input_file):
    print(f"Error: Input file '{input_file}' not found")
    sys.exit(1)

  LuaPacker(input_file, output_file).pack()
